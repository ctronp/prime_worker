use miller_rabin;

pub trait IsPrime {
    fn is_prime(&self) -> bool;
}

impl IsPrime for u64 {
    fn is_prime(&self) -> bool {
        miller_rabin::is_prime(self, 51)
    }
}

impl IsPrime for i64 {
    fn is_prime(&self) -> bool {
        miller_rabin::is_prime(&(*self as u64), 51)
    }
}

#[cfg(test)]
mod tests {
    use crate::IsPrime;
    use rug::Integer;
    use std::cmp::Ordering;
    use std::ops::Mul;

    #[test]
    fn it_works() {
        let result = 2 + 2;
        assert_eq!(result, 4);
    }

    #[test]
    fn rug() {
        let int1 = Integer::from(10);
        let int2 = Integer::from(10);
        assert_eq!(int1.cmp(&int2), Ordering::Equal);
    }

    #[test]
    fn not_prime_1() {
        assert!(!1u64.is_prime());
    }

    #[test]
    fn prime_2() {
        assert!(2u64.is_prime());
    }

    #[test]
    fn big_prime() {
        assert!(18446744073709551557u64.is_prime());
    }

    #[test]
    fn gmp_prime() {
        let s1 = "531137992816767098689588206552468627329593117727031\
        9231994441382004035598608522427391625022652292856688893294862465010153465793376527072394095\
        19978766587351943831270835393219031728127";
        let i1 = s1.parse::<Integer>().unwrap();
        assert_eq!(i1.is_probably_prime(50), rug::integer::IsPrime::Probably);
    }

    #[test]
    fn gmp_big_compose() {
        let s1 = "2519590847565789349402718324004839857142928212620403202777713783604366202070\
        7595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807\
        2877767359714183472702618963750149718246911650776133798590957000973304597488084284017974291\
        0064245869181719511874612151517265463228221686998754918242243363725908514186546204357679842\
        3387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143\
        6038339044149526344321901146575444541784240209246165157233507787077498171257724679629263863\
        56373289912154831438167899885040445364023527381951378636564391212010397122822120720357";
        let i1 = s1.parse::<Integer>().unwrap();
        assert_eq!(i1.is_probably_prime(50), rug::integer::IsPrime::No);
    }

    #[test]
    fn gmp_p_prime() {
        let s1 = "1079715941049749901632009212729594728505959347688246071601530385324670286752\
        3286147096614072552155347977848347772609606036702696825791227046890740477992644138013024542\
        1687965953962228879483686883313575932514148808400856530614521559206699505952226153035346819\
        225339629001055627558157468368627825917950758235987";
        let i1 = s1.parse::<Integer>().unwrap();
        assert_ne!(i1.is_probably_prime(50), rug::integer::IsPrime::No);
    }

    #[test]
    fn gmp_q_prime() {
        let s1 = "1574889140944611143826836867875542215750484255183385190849409626517891654497\
        3532619429330170623577320493660384372451180182252885153198192636379668157220284535454059601\
        7073770568699103525509096319420415865230884066884707237166882769606711959382440819194437136\
        622352278282415720957706380666594945332996141435113";
        let i1 = s1.parse::<Integer>().unwrap();
        assert_ne!(i1.is_probably_prime(50), rug::integer::IsPrime::No);
    }

    #[test]
    fn gmp_p_q() {
        let p = "1079715941049749901632009212729594728505959347688246071601530385324670286752\
        3286147096614072552155347977848347772609606036702696825791227046890740477992644138013024542\
        1687965953962228879483686883313575932514148808400856530614521559206699505952226153035346819\
        225339629001055627558157468368627825917950758235987";
        let q = "1574889140944611143826836867875542215750484255183385190849409626517891654497\
        3532619429330170623577320493660384372451180182252885153198192636379668157220284535454059601\
        7073770568699103525509096319420415865230884066884707237166882769606711959382440819194437136\
        622352278282415720957706380666594945332996141435113";
        let pq = "1700432910864043029879393406845407069555102380644237256830679740673220151329\
        7773470157283937608031977116639605460575199713010795305254630259027767150832193491472044611\
        5937967695192418450969131123643759709443894983455976986976022839423792529828461848546801458\
        9577097681063507647163280931833851277158071718829469793561211114304065212428111578962089181\
        9284481040904532925282843986037133330425109105828545134625680997262718520152723087628730930\
        4808559591834558925114480644137056131034782772725366276691172279348294361895366308329982219\
        98238931540142206253842675948682550428892559708858123457726262195624959946594502011531";
        let p = p.parse::<Integer>().unwrap();
        let q = q.parse::<Integer>().unwrap();
        let pq = pq.parse::<Integer>().unwrap();
        assert_ne!(p.is_probably_prime(50), rug::integer::IsPrime::No);
        assert_ne!(q.is_probably_prime(50), rug::integer::IsPrime::No);
        assert_eq!(pq.is_probably_prime(50), rug::integer::IsPrime::No);
        assert_eq!(pq, p.mul(q));
    }
}
